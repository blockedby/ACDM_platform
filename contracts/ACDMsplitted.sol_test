//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "hardhat/console.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "./ZepToken.sol";

contract ACDMStorage is AccessControl{
    using Counters for Counters.Counter;
    Counters.Counter public orderIndex;
    Counters.Counter public roundIndex;

    ZepToken public token;
    address public tokenAddress;
    uint256 public decimalsMultiplier;
    uint256 public roundTimestamp = 259200; // 3 days in POSIX
    mapping(uint256 => uint256) public soldToTraded;
    mapping(address => address) public referals;
    mapping(address => bool) public registered;
    mapping(address => uint256) public etherBalances;
    mapping(address => uint256) public tokenBalances;
    mapping(uint256 => Round) public rounds;

    struct Round {
        uint256 startedAt;
        State state;
        uint256 etherVolume;
        uint256 tokenVolume;
        uint256 priceOrOrderCount;
    }
    enum State {
        Sale,
        Trade
    }
    mapping(uint256 => Order) private orders;
    struct Order {
        address seller;
        uint256 initialAmount;
        uint256 soldAmount;
        uint256 pricePerToken;
        bool isOpen;
    }
    constructor(address _tokenAddress){
        token = ZepToken(_tokenAddress);
        tokenAddress = address(token);
        orderIndex.increment();
        roundIndex.increment();
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        decimalsMultiplier = 10**token.decimals();
    }

    function createSaleRound(

    ) public{
        
    }

    
}

contract ACDMPFunctions is AccessControl, ReentrancyGuard {
    address public storageContract;
    struct Order {
        address seller;
        uint256 initialAmount;
        uint256 soldAmount;
        uint256 pricePerToken;
        bool isOpen;
    }
    struct Round {
        uint256 startedAt;
        State state;
        uint256 etherVolume;
        uint256 tokenVolume;
        uint256 priceOrOrderCount;
    }
    enum State {
        Sale,
        Trade
    }
    event StageStarted(uint256 indexed _when, string indexed _which);
    event TokensSoldAtContract(
        address _buyer,
        uint256 indexed _price,
        uint256 indexed _amount
    );
    event TokensSoldAtOrder(
        uint256 indexed _orderId,
        address _buyer,
        uint256 indexed _price,
        uint256 indexed _amount
    );
    event OrderCreated(
        uint256 indexed _orderId,
        uint256 indexed _amount,
        uint256 indexed _pricePerToken,
        address _seller
    );
    event OrderClosedByBuyer(uint256 indexed _orderId);
    event OrderClosedBySeller(uint256 indexed _orderId);
    event OrderClosedByContract(uint256 indexed _orderId);
    event NewRegisteredUser(address indexed _user);

    constructor(address _storageContract) {
        storageContract = _storageContract;
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
        // need to setup storage role
        ACDMStorage(storageContract).rounds[ACDMStorage(storageContract).roundIndex.current()] = Round(
            block.timestamp,
            State.Sale,
            0,
            100000 * storageContract.decimalsMultiplier,
            10000 * 1 gwei
        );
        storageContract.token.mint(address(this), storageContract.rounds[storageContract.roundIndex.current()].tokenVolume);
        storageContract.registered[address(0)] = true;
        emit StageStarted(block.timestamp, "Sale");
    }

    function viewCurrentPlatformState()
        public
        view
        returns (string memory state)
    {
        if (storageContract.rounds[storageContract.roundIndex.current()].state == State.Sale) {
            state = "Sale";
        } else {
            state = "Trade";
        }
    }

    function getLeftTimestampOfStage() public view returns (uint256) {
        return (
            storageContract.roundTimestamp -
            // timestamp - (how long it is)
            (block.timestamp - storageContract.rounds[storageContract.roundIndex.current()].startedAt));
    }

    function register(address refFather) public {
        // register is mandatory
        require(storageContract.registered[msg.sender] == false, "You are already registered");
        require(storageContract.registered[refFather], "Promoter is not registered yet");
        storageContract.registered[msg.sender] = true;
        storageContract.referals[msg.sender] = refFather;
        emit NewRegisteredUser(msg.sender);
    }

    function getAvailableTokenAmount() public view returns (uint256) {
        require(
            storageContract.rounds[storageContract.roundIndex.current()].state == State.Sale,
            "Please, wait for next sale round"
        );
        return(storageContract.rounds[storageContract.roundIndex.current()].tokenVolume);
    }

    function getCurrentTokenPrice() public view returns (uint256) {
        require(
            storageContract.rounds[storageContract.roundIndex.current()].state == State.Sale,
            "Please, wait for next sale round"
        );
        return (storageContract.rounds[storageContract.roundIndex.current()].priceOrOrderCount);
    }

    function howManyEtherToTokenAmount(uint256 amountToBuy)
        public
        view
        returns (uint256)
    {
        require(
            storageContract.rounds[storageContract.roundIndex.current()].state == State.Sale,
            "Please wait for sale state"
        );
        return( storageContract.rounds[storageContract.roundIndex.current()].priceOrOrderCount * amountToBuy);
    }

    function howManyTokensCanIBuyForEther(uint256 _ether)
        public
        view
        returns (uint256)
    {
        require(
            storageContract.rounds[storageContract.roundIndex.current()].state == State.Sale,
            "Please wait for sale state"
        );
        return(
            (_ether / storageContract.rounds[storageContract.roundIndex.current()].priceOrOrderCount) *
            storageContract.decimalsMultiplier);
    }

    function getLastRoundId() public view returns (uint256) {
        return( storageContract.roundIndex.current());
    }

    function getLastOrderId() public view returns (uint256) {
        return (storageContract.orderIndex.current());
    }

    function buyAtContract() public payable stage(State.Sale) {
        require(msg.value > 0, "Please increase ether");
        uint256 amountToBuy = howManyTokensCanIBuyForEther(msg.value);
        console.log("Amount ot buy is ", amountToBuy);
        require(
            amountToBuy <= storageContract.rounds[storageContract.roundIndex.current()].tokenVolume,
            "Please check available balance"
        );
        storageContract.rounds[storageContract.roundIndex.current()].etherVolume += msg.value;
        storageContract.rounds[storageContract.roundIndex.current()].tokenVolume -= amountToBuy;
        if (storageContract.rounds[storageContract.roundIndex.current()].tokenVolume == 0) {
            changeStage();
        }
        console.log("Available is ", storageContract.rounds[storageContract.roundIndex.current()].tokenVolume);
        referalsBuyReward(msg.sender, msg.value);
        storageContract.token.transfer(msg.sender, amountToBuy);
        emit TokensSoldAtContract(
            msg.sender,
            storageContract.rounds[storageContract.roundIndex.current()].priceOrOrderCount,
            amountToBuy
        );
    }

    function createOrder(uint256 _amount, uint256 _pricePerToken)
        public
        stage(State.Trade)
    {
        storageContract.orders[storageContract.orderIndex.current()] = Order(
            msg.sender,
            _amount,
            0,
            _pricePerToken,
            true
        );
        storageContract.rounds[storageContract.roundIndex.current()].priceOrOrderCount++;
        emit OrderCreated(
            storageContract.orderIndex.current(),
            _amount,
            _pricePerToken,
            msg.sender
        );
        storageContract.orderIndex.increment();
        storageContract.token.transferFrom(msg.sender, address(this), _amount);
    }

    function buyAtOrder(uint256 _orderId)
        public
        payable
        stage(State.Trade)
        nonReentrant
    {
        require(storageContract.orders[_orderId].isOpen, "Order closed");
        uint256 tokenAmount = tokenAmountByEtherAtOrder(_orderId, msg.value);
        storageContract.orders[_orderId].soldAmount += tokenAmount;
        require(
            storageContract.orders[_orderId].soldAmount <= storageContract.orders[_orderId].initialAmount,
            "Value is too big"
        );
        referalsSellReward(storageContract.orders[_orderId].seller, msg.value);
        if (storageContract.orders[_orderId].soldAmount == storageContract.orders[_orderId].initialAmount) {
            storageContract.orders[_orderId].isOpen = false;
        }
        storageContract.rounds[storageContract.roundIndex.current()].etherVolume += msg.value;
        storageContract.rounds[storageContract.roundIndex.current()].tokenVolume += tokenAmount;
        storageContract.token.transfer(msg.sender, tokenAmount);
        emit TokensSoldAtOrder(
            _orderId,
            msg.sender,
            storageContract.orders[_orderId].pricePerToken,
            tokenAmount
        );
    }

    function closeOrder(uint256 _orderId) public nonReentrant {
        require(
            storageContract.orders[_orderId].seller == msg.sender,
            "Only seller can close it"
        );
        require(storageContract.orders[_orderId].isOpen == true, "It's already closed");
        storageContract.orders[_orderId].isOpen = false;
        storageContract.token.transfer(
            msg.sender,
            (storageContract.orders[_orderId].initialAmount - storageContract.orders[_orderId].soldAmount)
        );
        emit OrderClosedBySeller(_orderId);
    }

    function tokenAmountByEtherAtOrder(uint256 _orderId, uint256 _etherAmount)
        public
        view
        returns (uint256 _tokenAmount)
    {
        _tokenAmount =
            (_etherAmount / storageContract.orders[_orderId].pricePerToken) *
            storageContract.decimalsMultiplier;
    }

    function getFullPriceOfOrder(uint256 _orderId)
        public
        view
        returns (uint256 etherValue)
    {
        etherValue =
            ((storageContract.orders[_orderId].initialAmount - storageContract.orders[_orderId].soldAmount) *
                storageContract.orders[_orderId].pricePerToken) /
            storageContract.decimalsMultiplier;
    }

    function getOrderInfo(uint256 _id)
        public
        view
        returns (
            uint256,
            uint256,
            uint256,
            bool
        )
    {
        return( storageContract.orders[_id].initialAmount,
         storageContract.orders[_id].soldAmount,
         storageContract.orders[_id].pricePerToken,
         storageContract.orders[_id].isOpen);
    }

    function changeStage() private {
        console.log("State changing");
        if (storageContract.rounds[storageContract.roundIndex.current()].state == State.Sale) {
            if (storageContract.rounds[storageContract.roundIndex.current()].tokenVolume > 0) {
                storageContract.token.burn(
                    address(this),
                    storageContract.rounds[storageContract.roundIndex.current()].tokenVolume
                );
            }
            storageContract.roundIndex.increment();
            storageContract.rounds[storageContract.roundIndex.current()] = Round(
                block.timestamp,
                State.Trade,
                // false,
                0,
                0,
                0
            );
            emit StageStarted(block.timestamp, "Trade");
        } else {
            // setup tokenPrice
            uint256 newTokenPrice = (storageContract.rounds[storageContract.roundIndex.current() - 2]
                .priceOrOrderCount / 100) *
                103 +
                4000 *
                1 gwei;
            console.log("!new token price is ", newTokenPrice);
            // calculate tokens for new round
            uint256 tokensToMint = (storageContract.rounds[storageContract.roundIndex.current()].etherVolume *
                storageContract.decimalsMultiplier) / newTokenPrice;
            storageContract.token.mint(address(this), tokensToMint);
            console.log(tokensToMint, " tokens has been minted");
            for (
                uint256 i = storageContract.orderIndex.current() -
                    storageContract.rounds[storageContract.roundIndex.current()].priceOrOrderCount;
                i <= storageContract.rounds[storageContract.roundIndex.current()].priceOrOrderCount;
                i++
            ) {
                console.log("!checking ", i, "order");
                if (storageContract.orders[i].isOpen) {
                    console.log("!closing ", i, "order");
                    emit OrderClosedByContract(i);
                    storageContract.orders[i].isOpen = false;
                    storageContract.tokenBalances[storageContract.orders[i].seller] +=
                        storageContract.orders[i].initialAmount -
                        storageContract.orders[i].soldAmount;
                }
            }
            // change round back to sale
            storageContract.roundIndex.increment();
            storageContract.rounds[storageContract.roundIndex.current()] = Round(
                block.timestamp,
                State.Sale,
                0,
                tokensToMint,
                newTokenPrice
            );
            emit StageStarted(block.timestamp, "Sale");
        }
    }

    function changeStageRequest() public nonReentrant {
        require(
            block.timestamp >=
                storageContract.rounds[storageContract.roundIndex.current()].startedAt + storageContract.roundTimestamp,
            "Stage can't be ended now"
        );
        changeStage();
    }

    function viewMyEthBalance() public view returns (uint256) {
        return ( storageContract.etherBalances[msg.sender]);
    }

    function viewMyTokenBalance() public view returns (uint256) {
        return( storageContract.tokenBalances[msg.sender]);
    }

    function fetchEther() public nonReentrant {
        payable(msg.sender).transfer(storageContract.etherBalances[msg.sender]);
    }

    function fetchTokens() public nonReentrant {
        storageContract.token.transferFrom(
            address(this),
            msg.sender,
            storageContract.tokenBalances[msg.sender]
        );
    }

    function referalsBuyReward(address _buyer, uint256 _etherValue) internal {
        if (storageContract.referals[_buyer] != address(0)) {
            storageContract.etherBalances[storageContract.referals[_buyer]] += _etherValue / 20;
            if (storageContract.referals[storageContract.referals[_buyer]] != address(0)) {
                storageContract.etherBalances[storageContract.referals[storageContract.referals[_buyer]]] +=
                    (_etherValue / 100) *
                    3;
            }
        }
    }

    function referalsSellReward(address _seller, uint256 _etherValue) internal {
        storageContract.etherBalances[_seller] += _etherValue;
        if (storageContract.referals[_seller] != address(0)) {
            uint256 reward = _etherValue / 40;
            storageContract.etherBalances[storageContract.referals[_seller]] += reward;
            storageContract.etherBalances[_seller] -= reward;
            if (storageContract.referals[storageContract.referals[_seller]] != address(0)) {
                storageContract.etherBalances[storageContract.referals[storageContract.referals[_seller]]] += reward;
                storageContract.etherBalances[_seller] -= reward;
            }
        }
    }

    modifier stage(State _state) {
        if (
            block.timestamp >=
            storageContract.rounds[storageContract.roundIndex.current()].startedAt + storageContract.roundTimestamp
        ) {
            changeStage();
        }
        require(storageContract.registered[msg.sender], "You are not registered yet");
        require(
            _state == storageContract.rounds[storageContract.roundIndex.current()].state,
            "Can't be execute at this time, please check state of platform"
        );
        _;
    }
}
